rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isLoggedIn() {
      return request.auth != null;
    }
  	function isAdmin() {
      return request.auth != null && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    function isOwner() {
    	return request.auth != null && request.auth.uid == resource.data.readOnly.userId;
    }
    function authMatchesUser(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    function getProperty(name, fallback) {
      // request.resource contains the future state of the document
      return request.resource.data.get(name, fallback);
    }
    function createdFieldValid() {
      return (resource == null && request.resource.data.created == false) || (resource != null && request.resource.data.created == resource.data.created && resource.data.created == true);
    }
    function readOnlyFieldsUntouched() {
      let oldState = resource != null ? resource.data.get('readOnly', {}) : {};
      let newState = request.resource != null ? request.resource.data.get('readOnly', {}) : {};

      return oldState.diff(newState).affectedKeys().size() == 0
    }
    function rateLimitHit() {
      let user = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return user.data.readOnly.writeRate > 1 && debug(request.time.seconds() - user.data.readOnly.lastWriteTimestamp.seconds()) <= debug(user.data.readOnly.writeRate * 5);
    }

    function baseRequestValid() {
      return createdFieldValid() && readOnlyFieldsUntouched() && !rateLimitHit();
    }

    function getEntityFromCollection() {
      return get(/databases/$(database)/documents/$(request.resource.data.entityCollectionPath)/$(request.resource.data.entityId));
    }

    function getUniqueUserEntityId() {
      return request.resource.data.entityCollectionPath + '-' + request.resource.data.entityId + '-' + request.auth.uid;
    }

    match /{document=**} {
      allow read, write: if false;
    }
    match /users/{userId} {
      function isValidUser() {
        let controls = getProperty('controls', {});
        return
          baseRequestValid() &&
          request.resource.data.keys().hasOnly(['created', 'readOnly', 'controls', 'hasSeenAllSet', 'hasSeenWelcome', 'preferredInputMethod', 'locale']) &&
          getProperty('hasSeenAllSet', false) is bool &&
          getProperty('hasSeenWelcome', false) is bool &&
          getProperty('preferredInputMethod', '') in ['', 'keyboard', 'touch'] &&
          getProperty('locale', '') is string && getProperty('locale', '').size() < 3 &&
          controls is map && controls.keys().hasOnly(['MoveLeft', 'MoveRight', 'MoveDown', 'RotateClockwise', 'RotateAnticlockwise', 'Drop']) &&
          controls.get('MoveLeft', '') is string &&
          controls.get('MoveRight', '') is string &&
          controls.get('MoveDown', '') is string &&
          controls.get('RotateClockwise', '') is string &&
          controls.get('RotateAnticlockwise', '') is string &&
          controls.get('Drop', '') is string;
      }
    	allow read: if authMatchesUser(userId);
      allow create, delete: if false;
      allow update: if authMatchesUser(userId) && isValidUser();
    }
    match /challenges/{challengeId} {
      function isValidRewardCriteria(rewardCriteria) {
        return
          rewardCriteria.keys().hasOnly(['minLinesCleared', 'maxLinesCleared', 'minBlocksPlaced', 'maxBlocksPlaced', 'maxTimeTaken']) &&
          rewardCriteria.get('minLinesCleared', 0) is number && 
          rewardCriteria.get('maxLinesCleared', 0) is number && 
          rewardCriteria.get('minBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxTimeTaken', 0) is number;
      }
    	function isValidChallenge() {
        let finishCriteria = getProperty('finishCriteria', {});
        let simulationSettings = getProperty('simulationSettings', {});
        let rewardCriteria = getProperty('rewardCriteria', {});
        let title = getProperty('title', '');
        let description = getProperty('description', '');
        let grid = getProperty('grid', '');
        let allowedBlockLayoutIds = simulationSettings.get('allowedBlockLayoutIds', []);

      	return
          baseRequestValid() &&
          (!request.resource.data.get('isOfficial', false) || isAdmin()) &&
          request.resource.data.keys().hasOnly(['created', 'readOnly', 'description', 'finishCriteria', 'firstBlockLayoutId', 'grid', 'isMandatory', 'isOfficial', 'isPublished', 'locale', 'priority', 'simulationSettings', 'rewardCriteria', 'title']) &&
          title is string &&
          (title.size() == 0 || (title.size() < 21 && title.matches('[a-zA-Z0-9 ]+'))) &&
          description is string && description.size() < 280 &&
          getProperty('firstBlockLayoutId', '') is string &&
          grid is string && grid.size() > 0 &&
          getProperty('isOfficial', false) is bool &&
          getProperty('isMandatory', false) is bool &&
          getProperty('isPublished', false) is bool &&
          getProperty('locale', '') is string &&
          getProperty('priority', 0) is number &&
          simulationSettings is map &&
          simulationSettings.keys().hasOnly(['gravityEnabled', 'allowedBlockLayoutIds']) &&
          simulationSettings.get('gravityEnabled', false) is bool && 
          allowedBlockLayoutIds is list &&
          allowedBlockLayoutIds.size() < 4 &&
          (allowedBlockLayoutIds.size() < 1 || allowedBlockLayoutIds[0] is string) &&
          (allowedBlockLayoutIds.size() < 2 || allowedBlockLayoutIds[1] is string) &&
          (allowedBlockLayoutIds.size() < 3 || allowedBlockLayoutIds[2] is string) &&
          finishCriteria is map &&
          finishCriteria.keys().hasOnly(['maxBlocksPlaced', 'maxLinesCleared', 'maxTimeTaken', 'gridEmpty']) &&
          finishCriteria.get('maxBlocksPlaced', 0) is number && 
          finishCriteria.get('maxLinesCleared', 0) is number && 
          finishCriteria.get('maxTimeTaken', 0) is number && 
          finishCriteria.get('gridEmpty', false) is bool && 
          rewardCriteria is map &&
          rewardCriteria.keys().hasOnly(['all', 'bronze', 'silver', 'gold']) &&
          isValidRewardCriteria(rewardCriteria.get('all', {})) &&
          isValidRewardCriteria(rewardCriteria.get('bronze', {})) &&
          isValidRewardCriteria(rewardCriteria.get('silver', {})) &&
          isValidRewardCriteria(rewardCriteria.get('gold', {}));
      }
      allow create: if isValidChallenge() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.readOnly.coins > 0;
      allow update: if isValidChallenge() && isOwner() && (!resource.data.get('isPublished', false) || isAdmin());
      allow delete: if false;
      allow read: if true;
      
    }
    match /challengeAttempts/{challengeAttemptId} {
      allow read, write: if false;
      // TODO: before implementing this, add rate limiting
      /*allow read: if isOwner();
      allow delete: if false;
      allow create: if request.resource.data.keys().hasOnly(['code', 'medalIndex', 'stats']);
      allow update: if false;*/
    }
    match /ratings/{ratingId} {
      function isValidCollection() {
        return request.resource.data.entityCollectionPath == 'challenges';
      }
    	function isValidRating() {
        let entity = getEntityFromCollection();
      	return
          baseRequestValid() &&
          ratingId == getUniqueUserEntityId() &&
          isValidCollection() &&
          entity != null &&
          entity.data.isPublished &&
          entity.data.readOnly.userId != request.auth.uid &&
          request.resource.data.value is number && request.resource.data.value >= 1 && request.resource.data.value <= 5 &&
          request.resource.data.keys().hasOnly(['created', 'value', 'entityCollectionPath', 'entityId']);
      }
      allow create: if isValidRating();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /purchases/{purchaseId} {
      function isValidCollection() {
        return request.resource.data.entityCollectionPath == 'colors';
      }
    	function isValidPurchase() {
        let user = get(/databases/$(database)/documents/users/$(request.auth.uid));
        let entity = getEntityFromCollection();
      	return
          baseRequestValid() &&
          purchaseId == getUniqueUserEntityId() &&
          isValidCollection() &&
          entity != null &&
          user != null &&
          user.data.readOnly.coins >= entity.data.price &&
          request.resource.data.keys().hasOnly(['created', 'entityCollectionPath', 'entityId']);
      }
      allow create: if isValidPurchase();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /affiliates/{affiliateId} {
      allow write: if false;
      allow read: if isOwner();
    }
    match /affiliates/{affiliateId}/conversions/{userId} {
      function conversionIsValid() {
        let affiliate = get(/databases/$(database)/documents/affiliates/$(affiliateId));
        let user = get(/databases/$(database)/documents/users/$(userId));
        return
          baseRequestValid() &&
          authMatchesUser(userId) &&
          request.resource.data.keys().hasOnly(['created']) &&
          affiliate.data.readOnly.userId != userId &&
          !('referredByAffiliateId' in user.data.readOnly);
      }
      allow create: if conversionIsValid();
      allow read, update, delete: if false;
    }
    match /nicknames/{nicknameId} {
      allow read: if true;
      allow create: if
        baseRequestValid() &&
        isLoggedIn() &&
        nicknameId.size() > 1 &&
        nicknameId.size() < 16 &&
        nicknameId.matches('[a-zA-Z0-9 ]+') &&
        request.resource.data.keys().hasOnly(['created']);
      allow update, delete: if false;
    }
    match /colors/{document=**} {
      allow read: if true;
    }
    match /scoreboardEntries/{document=**} {
      allow read: if true;
    }
    match /rooms/{document=**} {
      allow read: if true;
    }
  }
}