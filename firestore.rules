rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  	function isAdmin(request) {
      return request.auth != null && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    function isOwner(request, resource) {
    	return request.auth != null && request.auth.uid == resource.data.userId;
    }
    function getProperty(name, fallback) {
      // request.resource contains the future state of the document
      return request.resource.data.get(name, fallback);
    }

    match /{document=**} {
      allow read, write: if false;
    }
    match /rooms/{document=**} {
      allow read: if true;
    }
    match /users/{userId} {
      function matchesUser(request, userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isValidUser() {
        let nickname = getProperty('nickname', '');
        let email = getProperty('email', '');
        let controls = getProperty('controls', []);
        return request.resource.data.keys().hasOnly(['nickname', 'email', 'referredByAffiliateId', 'controls', 'hasSeenAllSet', 'hasSeenWelcome', 'preferredInputMethod', 'locale']) &&
          debug(nickname) is string && nickname.size() > 1 && nickname.size() < 16 && nickname.matches('[a-zA-Z0-9]+') &&
          email is string && email.size() > 1 && email.size() < 360 && email.matches('.+@.+') &&
          getProperty('referredByAffiliateId', '') is string &&
          getProperty('hasSeenAllSet', false) is bool &&
          getProperty('hasSeenWelcome', false) is bool &&
          getProperty('preferredInputMethod', '') in ['', 'keyboard', 'touch'] &&
          getProperty('locale', '') is string && getProperty('locale', '').size() < 3 &&
          controls is map && controls.keys().hasOnly(['MoveLeft', 'MoveRight', 'MoveDown', 'RotateClockwise', 'RotateAnticlockwise', 'Drop']) &&
          controls.get('MoveLeft', '') is string &&
          controls.get('MoveRight', '') is string &&
          controls.get('MoveDown', '') is string &&
          controls.get('RotateClockwise', '') is string &&
          controls.get('RotateAnticlockwise', '') is string &&
          controls.get('Drop', '') is string;
      }
    	allow read: if matchesUser(request, userId);
      allow create, update: if matchesUser(request, userId) && isValidUser();
    }
    match /challenges/{challengeId} {
    	function isValidChallenge() {
      	return
          (!request.resource.data.get('isOfficial', false) || isAdmin(request)) &&
          request.resource.data.keys().hasOnly(['allowedActions', 'description', 'finishCriteria', 'firstBlockLayoutId', 'grid', 'isMandatory', 'isOfficial', 'isPublished', 'locale', 'priority', 'simulationSettings', 'rewardCriteria', 'title']);
      }
      allow create: if isValidChallenge() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.credits > 0;
      allow update: if isValidChallenge() && (isAdmin(request) || isOwner(request, resource)) && (!resource.data.isPublished || isAdmin(request));
      allow delete: if false;
      allow read: if true;
      match /simulationSettings {
        allow read: if true;
        allow delete: if true;
        allow create, update: if request.resource.data.keys().hasOnly(['gravityEnabled', 'allowedBlockLayoutIds']);
      }
      match /finishCriteria {
        allow read: if true;
        allow delete: if false;
        allow create, update: if request.resource.data.keys().hasOnly(['maxBlocks', 'maxLines', 'maxTime', 'emptyGrid', 'finishChallengeCellFilled']);
      }
      match /rewardCriteria {
        allow read: if true;
        allow delete: if false;
        allow create, update: if request.resource.data.keys().hasOnly(['bronze', 'silver', 'gold', 'all']);
      }
      match /rewardCriteria/{medal} {
        allow read: if true;
        allow delete: if false;
        allow create, update: if medal in ['bronze','silver','gold', 'all'] && request.resource.data.keys().hasOnly(['minLinesCleared', 'maxLinesCleared', 'maxBlocksPlaced', 'minBlocksPlaced', 'maxTimeTaken']);
      }
    }
    match /challengeAttempts/{challengeAttemptId} {
      allow read, write: if false;
      allow read: if isOwner(request, resource);
      allow delete: if false;
      allow create: if request.resource.data.keys().hasOnly(['code', 'medalIndex', 'stats']);
      allow update: if false;
    }
    match /ratings/{ratingId} {
      function isValidCollection() {
        return request.resource.data.entityCollection == 'challenges';
      }
    	function entityExists() {
      	return exists(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId));
      }
    	function isOwnerOfEntity() {
      	return get(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId)).data.userId == request.auth.uid;
      }
    	function calculateRatingId() {
      	return request.resource.data.entityCollection + '-' + request.resource.data.entityId + '-' + request.auth.uid;
      }
    	function isValidRating() {
      	return
          ratingId == calculateRatingId() &&
          isValidCollection() &&
          entityExists() &&
          !isOwnerOfEntity() &&
          request.resource.data.value >= 1 && request.resource.data.value <= 5 &&
          request.resource.data.keys().hasOnly(['value', 'entityCollection', 'entityId']);
      }
      allow create: if isValidRating();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /scoreboardEntries/{document=**} {
      allow read: if true;
    }
    match /affiliates/{affiliateId} {
      function canCreateAffiliate() {
      	return
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        	!('affiliateId' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data) &&
          request.resource.data.size() == 0;
      }
      allow create: if canCreateAffiliate();
      allow read: if isOwner(request, resource);
      allow update: if false;
      allow delete: if false;
    }
    match /colors/{document=**} {
      allow read: if true;
    }
  }
}