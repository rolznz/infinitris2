rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isLoggedIn() {
      return request.auth != null;
    }
  	function isAdmin() {
      return request.auth != null && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    function isOwner() {
    	return request.auth != null && request.auth.uid == resource.data.readOnly.userId;
    }
    function authMatchesUser(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    function getProperty(name, fallback) {
      // request.resource contains the future state of the document
      return request.resource.data.get(name, fallback);
    }
    function createdFieldValid() {
      return (resource == null && request.resource.data.created == false) || (resource != null && request.resource.data.created == resource.data.created && resource.data.created == true);
    }
    function readOnlyFieldsUntouched() {
      let oldState = resource != null ? resource.data.get('readOnly', {}) : {};
      let newState = request.resource != null ? request.resource.data.get('readOnly', {}) : {};

      return oldState.diff(newState).affectedKeys().size() == 0
    }
    function entityValid() {
      return createdFieldValid() && readOnlyFieldsUntouched();
    }

    match /{document=**} {
      allow read, write: if false;
    }
    match /users/{userId} {
      function isValidUser() {
        let controls = getProperty('controls', {});
        return request.resource.data.keys().hasOnly(['created', 'readOnly', 'controls', 'hasSeenAllSet', 'hasSeenWelcome', 'preferredInputMethod', 'locale']) &&
          entityValid() &&
          getProperty('hasSeenAllSet', false) is bool &&
          getProperty('hasSeenWelcome', false) is bool &&
          getProperty('preferredInputMethod', '') in ['', 'keyboard', 'touch'] &&
          getProperty('locale', '') is string && getProperty('locale', '').size() < 3 &&
          controls is map && controls.keys().hasOnly(['MoveLeft', 'MoveRight', 'MoveDown', 'RotateClockwise', 'RotateAnticlockwise', 'Drop']) &&
          controls.get('MoveLeft', '') is string &&
          controls.get('MoveRight', '') is string &&
          controls.get('MoveDown', '') is string &&
          controls.get('RotateClockwise', '') is string &&
          controls.get('RotateAnticlockwise', '') is string &&
          controls.get('Drop', '') is string;
      }
    	allow read: if authMatchesUser(userId);
      allow create, delete: if false;
      allow update: if authMatchesUser(userId) && isValidUser();
    }
    match /challenges/{challengeId} {
      function isValidRewardCriteria(rewardCriteria) {
        return
          rewardCriteria.keys().hasOnly(['minLinesCleared', 'maxLinesCleared', 'minBlocksPlaced', 'maxBlocksPlaced', 'maxTimeTaken']) &&
          rewardCriteria.get('minLinesCleared', 0) is number && 
          rewardCriteria.get('maxLinesCleared', 0) is number && 
          rewardCriteria.get('minBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxTimeTaken', 0) is number;
      }
    	function isValidChallenge() {
        let finishCriteria = getProperty('finishCriteria', {});
        let simulationSettings = getProperty('simulationSettings', {});
        let rewardCriteria = getProperty('rewardCriteria', {});
        let title = getProperty('title', '');
        let description = getProperty('description', '');
        let grid = getProperty('grid', '');
        let allowedBlockLayoutIds = simulationSettings.get('allowedBlockLayoutIds', []);

      	return
          (!request.resource.data.get('isOfficial', false) || isAdmin()) &&
          entityValid() &&
          request.resource.data.keys().hasOnly(['created', 'readOnly', 'description', 'finishCriteria', 'firstBlockLayoutId', 'grid', 'isMandatory', 'isOfficial', 'isPublished', 'locale', 'priority', 'simulationSettings', 'rewardCriteria', 'title']) &&
          title is string &&
          (title.size() == 0 || (title.size() < 21 && title.matches('[a-zA-Z0-9 ]+'))) &&
          description is string && description.size() < 280 &&
          getProperty('firstBlockLayoutId', '') is string &&
          grid is string && grid.size() > 0 &&
          getProperty('isOfficial', false) is bool &&
          getProperty('isMandatory', false) is bool &&
          getProperty('isPublished', false) is bool &&
          getProperty('locale', '') is string &&
          getProperty('priority', 0) is number &&
          simulationSettings is map &&
          simulationSettings.keys().hasOnly(['gravityEnabled', 'allowedBlockLayoutIds']) &&
          simulationSettings.get('gravityEnabled', false) is bool && 
          allowedBlockLayoutIds is list &&
          allowedBlockLayoutIds.size() < 4 &&
          (allowedBlockLayoutIds.size() < 1 || allowedBlockLayoutIds[0] is string) &&
          (allowedBlockLayoutIds.size() < 2 || allowedBlockLayoutIds[1] is string) &&
          (allowedBlockLayoutIds.size() < 3 || allowedBlockLayoutIds[2] is string) &&
          finishCriteria is map &&
          finishCriteria.keys().hasOnly(['maxBlocksPlaced', 'maxLinesCleared', 'maxTimeTaken', 'gridEmpty']) &&
          finishCriteria.get('maxBlocksPlaced', 0) is number && 
          finishCriteria.get('maxLinesCleared', 0) is number && 
          finishCriteria.get('maxTimeTaken', 0) is number && 
          finishCriteria.get('gridEmpty', false) is bool && 
          rewardCriteria is map &&
          rewardCriteria.keys().hasOnly(['all', 'bronze', 'silver', 'gold']) &&
          isValidRewardCriteria(rewardCriteria.get('all', {})) &&
          isValidRewardCriteria(rewardCriteria.get('bronze', {})) &&
          isValidRewardCriteria(rewardCriteria.get('silver', {})) &&
          isValidRewardCriteria(rewardCriteria.get('gold', {}));
      }
      allow create: if isValidChallenge() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.readOnly.coins > 0;
      allow update: if isValidChallenge() && isOwner() && (!resource.data.get('isPublished', false) || isAdmin());
      allow delete: if false;
      allow read: if true;
      
    }
    match /challengeAttempts/{challengeAttemptId} {
      allow read, write: if false;
      // TODO: before implementing this, add rate limiting
      /*allow read: if isOwner();
      allow delete: if false;
      allow create: if request.resource.data.keys().hasOnly(['code', 'medalIndex', 'stats']);
      allow update: if false;*/
    }
    match /ratings/{ratingId} {
      function isValidCollection() {
        return request.resource.data.entityCollection == 'challenges';
      }
    	function entityExists() {
      	return exists(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId));
      }
      function entityIsPublished() {
      	return get(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId)).data.isPublished == true;
      }
    	function isOwnerOfEntity() {
      	return get(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId)).data.readOnly.userId == request.auth.uid;
      }
    	function calculateRatingId() {
      	return request.resource.data.entityCollection + '-' + request.resource.data.entityId + '-' + request.auth.uid;
      }
    	function isValidRating() {
      	return
          entityValid() &&
          ratingId == calculateRatingId() &&
          isValidCollection() &&
          entityExists() &&
          entityIsPublished() &&
          !isOwnerOfEntity() &&
          request.resource.data.value is number && request.resource.data.value >= 1 && request.resource.data.value <= 5 &&
          request.resource.data.keys().hasOnly(['created', 'readOnly', 'value', 'entityCollection', 'entityId']);
      }
      allow create: if isValidRating();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /affiliates/{affiliateId} {
      allow write: if false;
      allow read: if isOwner();
    }
    match /affiliates/{affiliateId}/conversions/{userId} {
      function conversionIsValid() {
        let affiliate = get(/databases/$(database)/documents/affiliates/$(affiliateId));
        let user = get(/databases/$(database)/documents/users/$(userId));
        return authMatchesUser(userId) &&
        entityValid() &&
        request.resource.data.keys().hasOnly(['created']) &&
        affiliate.data.readOnly.userId != userId &&
        !('referredByAffiliateId' in user.data.readOnly);
      }
      allow create: if conversionIsValid();
      allow read, update, delete: if false;
    }
    match /nicknames/{nicknameId} {
      allow read: if true;
      allow create: if
        isLoggedIn() &&
        nicknameId.size() > 1 &&
        nicknameId.size() < 16 &&
        nicknameId.matches('[a-zA-Z0-9 ]+') &&
        entityValid() &&
        request.resource.data.keys().hasOnly(['created']);
      allow update, delete: if false;
    }
    match /colors/{document=**} {
      allow read: if true;
    }
    match /scoreboardEntries/{document=**} {
      allow read: if true;
    }
    match /rooms/{document=**} {
      allow read: if true;
    }
  }
}