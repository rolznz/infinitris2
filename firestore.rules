rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function withCoreFieldNames(fieldNames) {
      return ['created', 'readOnly', 'userId'].concat(fieldNames);
    }
    function entityHasExpectedFields(fieldNames) {
      return request.resource.data.keys().hasOnly(withCoreFieldNames(fieldNames));
    }
    function isLoggedIn() {
      return request.auth != null;
    }
  	function isAdmin() {
      return
        request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.readOnly.isAdmin == true;
    }
    function isOwner() {
    	return request.auth != null && request.auth.uid == resource.data.userId;
    }
    function authMatchesUser(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    function getProperty(name, fallback) {
      // request.resource contains the future state of the document
      return request.resource.data.get(name, fallback);
    }
    function createdFieldValid() {
      return (resource == null && request.resource.data.created == false) || (resource != null && request.resource.data.created == resource.data.created && resource.data.created == true);
    }
    function userIdFieldValid() {
      return
        (authMatchesUser(request.resource.data.userId) || isAdmin()) &&
        (resource == null || (resource != null && request.resource.data.userId == resource.data.userId));
    }
    function readOnlyFieldsUntouched() {
      let oldState = resource != null ? resource.data.get('readOnly', {}) : {};
      let newState = request.resource != null ? request.resource.data.get('readOnly', {}) : {};

      return oldState.diff(newState).affectedKeys().size() == 0
    }
    function rateLimitHit() {
      let user = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return user.data.readOnly.writeRate > 1 && request.time.toMillis() - user.data.readOnly.lastWriteTimestamp.toMillis() <= user.data.readOnly.writeRate * 5000;
    }

    function baseRequestValid() {
      return userIdFieldValid() && createdFieldValid() && readOnlyFieldsUntouched() && !rateLimitHit();
    }

    function getEntityFromCollection() {
      return get(/databases/$(database)/documents/$(request.resource.data.entityCollectionPath)/$(request.resource.data.entityId));
    }

    function getUniqueUserEntityId() {
      return request.resource.data.entityCollectionPath + '-' + request.resource.data.entityId + '-' + request.auth.uid;
    }

    match /{document=**} {
      allow read, write: if false;
    }
    match /users/{userId} {
      function verifyControls(controls) {
        return controls is map && controls.keys().hasOnly(['MoveLeft', 'MoveRight', 'MoveDown', 'RotateClockwise', 'RotateAnticlockwise', 'Drop', 'Chat', 'Esc']) &&
          controls.get('MoveLeft', '') is string &&
          controls.get('MoveRight', '') is string &&
          controls.get('MoveDown', '') is string &&
          controls.get('RotateClockwise', '') is string &&
          controls.get('RotateAnticlockwise', '') is string &&
          controls.get('Drop', '') is string &&
          controls.get('Chat', '') is string &&
          controls.get('Esc', '') is string;
      }
      function isValidUser() {
        return
          baseRequestValid() &&
          entityHasExpectedFields(['controls_keyboard', 'controls_gamepad', 'preferredInputMethod', 'locale', 'musicOn', 'sfxOn', 'appTheme', 'musicVolume', 'sfxVolume', 'rendererType', 'rendererQuality', 'selectedCharacterId', 'unlockedFeatures', 'completedOfficialChallengeIds','gridLineType', 'blockShadowType', 'showNicknames', 'showPatterns', 'showFaces', 'showUI', 'useCustomRepeat', 'customRepeatInitialDelay', 'customRepeatRate', 'allowRepeatedRotations']) &&
          getProperty('unlockedFeatures', []) is list &&
          getProperty('completedOfficialChallengeIds', []) is list &&
          getProperty('useCustomRepeat', false) is bool &&
          getProperty('customRepeatRate', 0) is number &&
          getProperty('customRepeatInitialDelay', 0) is number &&
          getProperty('allowRepeatedRotations', false) is bool &&
          getProperty('musicOn', false) is bool &&
          getProperty('musicVolume', 0) is number &&
          getProperty('sfxOn', false) is bool &&
          getProperty('sfxVolume', 0) is number &&
          getProperty('showNicknames', false) is bool &&
          getProperty('showPatterns', false) is bool &&
          getProperty('showFaces', false) is bool &&
          getProperty('gridLineType', '') is string &&
          getProperty('blockShadowType', '') is string &&
          getProperty('preferredInputMethod', '') in ['', 'keyboard', 'touch'] &&
          getProperty('locale', '') is string && getProperty('locale', '').size() < 3 &&
          getProperty('appTheme', '') in ['', 'light', 'dark', 'default'] &&
          getProperty('rendererType', '') in ['', 'minimal', 'infinitris2'] &&
          getProperty('rendererQuality', '') in ['', 'low', 'medium', 'high'] &&
          (getProperty('selectedCharacterId', '0') == '0' || request.resource.data.selectedCharacterId in resource.data.readOnly.characterIds) &&
          verifyControls(getProperty('controls_keyboard', {})) &&
          verifyControls(getProperty('controls_gamepad', {}));
      }
    	allow read: if authMatchesUser(userId);
      allow create, delete: if false;
      allow update: if authMatchesUser(userId) && isValidUser();
    }
    match /challenges/{challengeId} {
      function isValidRewardCriteria(rewardCriteria) {
        return
          rewardCriteria.keys().hasOnly(['minLinesCleared', 'maxLinesCleared', 'minBlocksPlaced', 'maxBlocksPlaced', 'maxTimeTakenMs']) &&
          rewardCriteria.get('minLinesCleared', 0) is number && 
          rewardCriteria.get('maxLinesCleared', 0) is number && 
          rewardCriteria.get('minBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxBlocksPlaced', 0) is number && 
          rewardCriteria.get('maxTimeTakenMs', 0) is number;
      }
    	function isValidChallenge() {
        let finishCriteria = getProperty('finishCriteria', {});
        let simulationSettings = getProperty('simulationSettings', {});
        let rewardCriteria = getProperty('rewardCriteria', {});
        let title = getProperty('title', '');
        let description = getProperty('description', '');
        let grid = getProperty('grid', '');
        let allowedBlockLayoutIds = simulationSettings.get('allowedBlockLayoutIds', []);

      	return
          baseRequestValid() &&
          entityHasExpectedFields(['description', 'finishCriteria', 'grid', 'isMandatory', 'isOfficial', 'isPublished', 'locale', 'priority', 'simulationSettings', 'rewardCriteria', 'title', 'worldType', 'worldVariation', 'isTemplate']) &&
          (!request.resource.data.get('isOfficial', false) || isAdmin()) &&
          (!request.resource.data.get('isTemplate', false) || isAdmin()) &&
          title is string &&
          (title.size() == 0 || (title.size() <= 16 && title.matches('[a-z0-9 ]+'))) &&
          description is string && description.size() < 280 &&
          grid is string && grid.size() > 0 &&
          getProperty('isOfficial', false) is bool &&
          getProperty('isMandatory', false) is bool &&
          getProperty('isPublished', false) is bool &&
          getProperty('locale', '') is string &&
          getProperty('priority', 0) is number &&
          getProperty('worldType', 'grass') in ['grass', 'desert', 'volcano', 'space'] &&
          getProperty('worldVariation', '0') in ['0', '1', '2', '3', '4', '5'] &&
          simulationSettings is map &&
          simulationSettings.keys().hasOnly(['layoutSetId', 'gravityEnabled', 'replaceUnplayableBlocks', 'allowedBlockLayoutIds', 'gameModeType']) &&
          simulationSettings.get('gameModeType', '') is string &&
          simulationSettings.get('gravityEnabled', false) is bool &&
          simulationSettings.get('replaceUnplayableBlocks', false) is bool &&
          simulationSettings.get('layoutSetId', '') is string && simulationSettings.get('layoutSetId', '').size() < 100 &&
          allowedBlockLayoutIds is list &&
          allowedBlockLayoutIds.size() < 4 &&
          (allowedBlockLayoutIds.size() < 1 || allowedBlockLayoutIds[0] is string) &&
          (allowedBlockLayoutIds.size() < 2 || allowedBlockLayoutIds[1] is string) &&
          (allowedBlockLayoutIds.size() < 3 || allowedBlockLayoutIds[2] is string) &&
          finishCriteria is map &&
          finishCriteria.keys().hasOnly(['maxBlocksPlaced', 'maxLinesCleared', 'maxTimeTakenMs', 'gridEmpty']) &&
          finishCriteria.get('maxBlocksPlaced', 0) is number && 
          finishCriteria.get('maxLinesCleared', 0) is number && 
          finishCriteria.get('maxTimeTakenMs', 0) is number && 
          finishCriteria.get('gridEmpty', false) is bool && 
          rewardCriteria is map &&
          rewardCriteria.keys().hasOnly(['all', 'bronze', 'silver', 'gold']) &&
          isValidRewardCriteria(rewardCriteria.get('all', {})) &&
          isValidRewardCriteria(rewardCriteria.get('bronze', {})) &&
          isValidRewardCriteria(rewardCriteria.get('silver', {})) &&
          isValidRewardCriteria(rewardCriteria.get('gold', {}));
      }
      allow create: if isValidChallenge() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.readOnly.coins > 0;
      allow update: if isValidChallenge() && (!resource.data.get('isPublished', false) || isAdmin());
      allow delete: if isAdmin();
      allow read: if true;
      
    }
    match /challengeAttempts/{challengeAttemptId} {
      function isValidChallengeAttempt() {
        let challenge = get(/databases/$(database)/documents/challenges/$(request.resource.data.challengeId));
        return
          isLoggedIn() &&
          baseRequestValid() &&
          entityHasExpectedFields(['challengeId', 'status', 'medalIndex', 'stats', 'clientVersion', 'recording']) &&
          challenge != null &&
          challenge.data.isPublished &&
          request.resource.data.status == 'success' &&
          request.resource.data.get('clientVersion', '') is string &&
          request.resource.data.get('recording', {}) is map &&
          request.resource.data.get('recording', {}).keys().hasOnly(['frames', 'simulationRootSeed']) &&
          request.resource.data.get('recording', {}).get('simulationRootSeed', 0) is number &&
          request.resource.data.get('recording', {}).get('frames', []) is list &&
          request.resource.data.medalIndex is number && request.resource.data.medalIndex > 0 && request.resource.data.medalIndex < 4 &&
          request.resource.data.stats is map && request.resource.data.stats.keys().hasOnly(['linesCleared', 'blocksPlaced', 'timeTakenMs']) &&
          request.resource.data.stats.linesCleared is number &&
          request.resource.data.stats.blocksPlaced is number &&
          request.resource.data.stats.timeTakenMs is number;
      }
      allow read: if true;
      allow delete: if false;
      allow create: if isValidChallengeAttempt();
      allow update: if false;
    }
    match /ratings/{ratingId} {
      function isValidCollection() {
        return request.resource.data.entityCollectionPath == 'challenges';
      }
    	function isValidRating() {
        let entity = getEntityFromCollection();
      	return
          baseRequestValid() &&
          entityHasExpectedFields(['created', 'value', 'entityCollectionPath', 'entityId']) &&
          ratingId == getUniqueUserEntityId() &&
          isValidCollection() &&
          entity != null &&
          entity.data.isPublished &&
          entity.data.userId != request.auth.uid &&
          request.resource.data.value is number && request.resource.data.value >= 1 && request.resource.data.value <= 5;
      }
      allow create: if isValidRating();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /issueReports/{issueReportId} {
      function isValidCollection() {
        return request.resource.data.entityCollectionPath == 'challengeAttempts';
      }
    	function isValidIssueReport() {
        let entity = getEntityFromCollection();
      	return
          baseRequestValid() &&
          entityHasExpectedFields(['created', 'entityCollectionPath', 'entityId']) &&
          issueReportId == getUniqueUserEntityId() &&
          isValidCollection() &&
          entity != null;
      }
      allow create: if isValidIssueReport();
      allow update: if false;
      allow delete: if false;
      allow read: if false;
    }
    match /purchases/{purchaseId} {
      function isValidCollection() {
        return request.resource.data.entityCollectionPath == 'characters';
      }
    	function isValidPurchase() {
        let user = get(/databases/$(database)/documents/users/$(request.auth.uid));
        let entity = getEntityFromCollection();
      	return
          baseRequestValid() &&
          entityHasExpectedFields(['entityCollectionPath', 'entityId']) &&
          purchaseId == getUniqueUserEntityId() &&
          isValidCollection() &&
          entity != null &&
          user != null &&
          user.data.readOnly.coins >= entity.data.price &&
          (entity.data.get('maxPurchases', -1) < 0 || entity.data.maxPurchases > entity.data.get('numPurchases', 0));
      }
      allow create: if isValidPurchase();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /affiliates/{affiliateId} {
      allow write: if false;
      allow read: if isOwner();
    }
    match /affiliates/{affiliateId}/conversions/{userId} {
      function conversionIsValid() {
        let affiliate = get(/databases/$(database)/documents/affiliates/$(affiliateId));
        let user = get(/databases/$(database)/documents/users/$(userId));
        return
          baseRequestValid() &&
          entityHasExpectedFields([]) &&
          affiliate.data.userId != userId &&
          !('referredByAffiliateId' in user.data.readOnly);
      }
      allow create: if conversionIsValid();
      allow read, update, delete: if false;
    }
    match /nicknames/{nicknameId} {
      allow read: if true;
      allow create: if
        baseRequestValid() &&
        entityHasExpectedFields([]) &&
        isLoggedIn() &&
        nicknameId.size() > 1 &&
        nicknameId.size() <= 10 &&
        nicknameId.matches('[a-z0-9 ]+');
      allow update, delete: if false;
    }
    match /characters/{document=**} {
      allow read: if true;
    }
    match /scoreboardEntries/{document=**} {
      allow read: if true;
    }
    match /rooms/{document=**} {
      allow read: if true;
    }
    match /servers/{document=**} {
      allow read: if true;
    }
    match /donations/{document=**} {
      allow read: if true;
    }
    match /payments/{document=**} {
      allow get: if true;
    }
    match /settings/{document=**} {
      allow get: if true;
    }
  }
}