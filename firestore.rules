rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  	function isAdmin() {
      return request.auth != null && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    function isOwner() {
    	return request.auth != null && request.auth.uid == resource.data.readOnly.userId;
    }
    function getProperty(name, fallback) {
      // request.resource contains the future state of the document
      return request.resource.data.get(name, fallback);
    }
    function readOnlyFieldsUntouched() {
      let oldState = debug(resource.data.get('readOnly', {}));
      let newState = debug(request.resource.data.get('readOnly', {}));

      return oldState.diff(newState).affectedKeys().size() == 0
    }

    match /{document=**} {
      allow read, write: if false;
    }
    match /rooms/{document=**} {
      allow read: if true;
    }
    match /users/{userId} {
      function matchesUser(request, userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isValidUser() {
        let nickname = getProperty('nickname', '');
        let email = getProperty('email', '');
        let controls = getProperty('controls', []);
        return request.resource.data.keys().hasOnly(['readOnly', 'controls', 'hasSeenAllSet', 'hasSeenWelcome', 'preferredInputMethod', 'locale']) &&
          readOnlyFieldsUntouched() &&
          getProperty('hasSeenAllSet', false) is bool &&
          getProperty('hasSeenWelcome', false) is bool &&
          getProperty('preferredInputMethod', '') in ['', 'keyboard', 'touch'] &&
          getProperty('locale', '') is string && getProperty('locale', '').size() < 3 &&
          controls is map && controls.keys().hasOnly(['MoveLeft', 'MoveRight', 'MoveDown', 'RotateClockwise', 'RotateAnticlockwise', 'Drop']) &&
          controls.get('MoveLeft', '') is string &&
          controls.get('MoveRight', '') is string &&
          controls.get('MoveDown', '') is string &&
          controls.get('RotateClockwise', '') is string &&
          controls.get('RotateAnticlockwise', '') is string &&
          controls.get('Drop', '') is string;
      }
    	allow read: if matchesUser(request, userId);
      allow create, delete: if false;
      allow update: if matchesUser(request, userId) && isValidUser();
    }
    /*match /users/{userId}/requests/nickname
    nickname is string && nickname.size() > 1 && nickname.size() < 16 && nickname.matches('[a-zA-Z0-9]+')
    */
    match /challenges/{challengeId} {
    	function isValidChallenge() {
      	return
          (!request.resource.data.get('isOfficial', false) || isAdmin()) &&
          request.resource.data.keys().hasOnly(['readOnly', 'allowedActions', 'description', 'finishCriteria', 'firstBlockLayoutId', 'grid', 'isMandatory', 'isOfficial', 'isPublished', 'locale', 'priority', 'simulationSettings', 'rewardCriteria', 'title']) &&
          readOnlyFieldsUntouched();
      }
      allow create: if isValidChallenge() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.credits > 0;
      allow update: if isValidChallenge() && (isAdmin() || isOwner()) && (!resource.data.get('isPublished', false) || isAdmin());
      allow delete: if false;
      allow read: if true;
      
    }
    match /challengeAttempts/{challengeAttemptId} {
      allow read, write: if false;
      // TODO: before implementing this, add rate limiting
      /*allow read: if isOwner();
      allow delete: if false;
      allow create: if request.resource.data.keys().hasOnly(['code', 'medalIndex', 'stats']);
      allow update: if false;*/
    }
    match /challengeTranslations/{challengeTranslationId} {
      allow read, write: if false;
    }
    match /ratings/{ratingId} {
      function isValidCollection() {
        return request.resource.data.entityCollection == 'challenges';
      }
    	function entityExists() {
      	return exists(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId));
      }
    	function isOwnerOfEntity() {
      	return get(/databases/$(database)/documents/$(request.resource.data.entityCollection)/$(request.resource.data.entityId)).data.userId == request.auth.uid;
      }
    	function calculateRatingId() {
      	return request.resource.data.entityCollection + '-' + request.resource.data.entityId + '-' + request.auth.uid;
      }
    	function isValidRating() {
      	return
          ratingId == calculateRatingId() &&
          isValidCollection() &&
          entityExists() &&
          !isOwnerOfEntity() &&
          request.resource.data.value >= 1 && request.resource.data.value <= 5 &&
          request.resource.data.keys().hasOnly(['value', 'entityCollection', 'entityId']);
      }
      allow create: if isValidRating();
      allow update: if false;
      allow delete: if false;
      allow read: if true;
    }
    match /scoreboardEntries/{document=**} {
      allow read: if true;
    }
    match /affiliates/{affiliateId} {
      function canCreateAffiliate() {
      	return
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        	!('affiliateId' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data) &&
          request.resource.data.size() == 0;
      }
      allow create: if canCreateAffiliate();
      allow read: if isOwner();
      allow update: if false;
      allow delete: if false;
    }
    match /colors/{document=**} {
      allow read: if true;
    }
  }
}